<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Scattered Technologies</title><link href="http://rjw57.github.io/blog/" rel="alternate"></link><link href="http://rjw57.github.io/blog/feeds/feeds/gis.atom.xml" rel="self"></link><id>http://rjw57.github.io/blog/</id><updated>2013-06-19T00:00:00+02:00</updated><entry><title>Processing the UK's real-time traffic data with Python</title><link href="http://rjw57.github.io/blog/2013/06/19/real-time-traffic-data/" rel="alternate"></link><updated>2013-06-19T00:00:00+02:00</updated><author><name>Rich Wareham</name></author><id>tag:rjw57.github.io/blog,2013-06-19:2013/06/19/real-time-traffic-data/</id><summary type="html">&lt;p&gt;&lt;img alt="An example traffic map" src="http://rjw57.github.io/blog/static/images/realtime-traffic-data/england-traffic-delays.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;In this post: parsing the real-time traffic feed from the &lt;a href="http://www.highways.gov.uk/"&gt;UK Highways Agency&lt;/a&gt;; plotting
the UK's major road links an map using the Ordinance Survey national grid; colouring the result nicely.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;The UK Government's &lt;a href="http://data.gov.uk/"&gt;data.gov.uk&lt;/a&gt; website is a treasure-trove of data just waiting to be
downloaded. Recently I started some pre-research on a project at work to do with traffic congestion prediction for which
getting some actual historical data on the state of the roads in the UK would be useful. Luckily the data.gov.uk website
has a section on &lt;a href="http://data.gov.uk/dataset/live-traffic-information-from-the-highways-agency-road-network"&gt;live data from the UK Highways Agency&lt;/a&gt;. I decided it would be useful to play with
this data and see what I could get out of it.&lt;/p&gt;
&lt;h2&gt;What is available&lt;/h2&gt;
&lt;p&gt;The data itself takes the form of XML documents which are updated every so often with the current state of the road
network in England. Some files are updated around once every 10 minutes. For example, the UK Highways Agency maintain a
network of &lt;a href="http://en.wikipedia.org/wiki/Automatic_number_plate_recognition"&gt;Automatic number plate recognition&lt;/a&gt; systems which measure journey times along major links in the UK's
road network. It uses this information to publish three bits of data about each link:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the current journey time;&lt;/li&gt;
&lt;li&gt;the typical journey time; and&lt;/li&gt;
&lt;li&gt;the ideal journey time in free-flowing traffic.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It is such data which is used to create traffic delay maps such as the one at the top of this post or
&lt;a href="http://www.trafficengland.com/map.aspx?long0=-128.10065526342794&amp;amp;lat0=3205.4288365561897&amp;amp;long1=119.32156695879439&amp;amp;lat1=3099.8639213019524&amp;amp;ct=true"&gt;elsewhere online&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Road locations&lt;/h2&gt;
&lt;p&gt;According to data.gov.uk, &lt;a href="http://hatrafficinfo.dft.gov.uk/feeds/datex/England/PredefinedLocationJourneyTimeSections/content.xml"&gt;the location data&lt;/a&gt; for journey time data is available from
the following URL:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;http://hatrafficinfo.dft.gov.uk/feeds/datex/England/PredefinedLocationJourneyTimeSections/content.xml&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This document defines a list of &lt;em&gt;locations&lt;/em&gt; which, for journey times, are starting and ending points. If we join a line
from the start point to the end point for each location we'll end up with a crude road-map of England.  There is a
corresponding &lt;a href="http://www.datex2.eu/sites/www.datex2.eu/files/NTIS_DATEXII_v2.0_0.pdf"&gt;document&lt;/a&gt; which describes the schema for this XML document but, for our purposes, it is
sufficient to look at a single truncated and annotated example. I've left out elements which we wont be using.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nt"&gt;&amp;lt;d2LogicalModel&lt;/span&gt; &lt;span class="na"&gt;xmlns=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://datex2.eu/schema/1_0/1_0&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;modelBaseVersion=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;1.0&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;payloadPublication&lt;/span&gt; &lt;span class="na"&gt;xmlns:xsi=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;&lt;/span&gt;
    &lt;span class="na"&gt;xsi:type=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;PredefinedLocationsPublication&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;lang=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;en&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;

    &lt;span class="c"&gt;&amp;lt;!-- An ISO8601 date for the data --&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;publicationTime&amp;gt;&lt;/span&gt;2013-06-12T11:59:15+01:00&lt;span class="nt"&gt;&amp;lt;/publicationTime&amp;gt;&lt;/span&gt;

    &lt;span class="c"&gt;&amp;lt;!-- This set of locations is for journey time data --&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;predefinedLocationSet&lt;/span&gt; &lt;span class="na"&gt;id=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;GUID-NTCC-JourneyTimeSections&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;

      &lt;span class="c"&gt;&amp;lt;!-- There is one predefinedLocation element for each section of road --&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;predefinedLocation&lt;/span&gt; &lt;span class="na"&gt;id=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Section11017&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;

        &lt;span class="c"&gt;&amp;lt;!-- The road location: a line segment joining a &amp;#39;from&amp;#39; point to a &amp;#39;to&amp;#39; point --&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;predefinedLocation&lt;/span&gt; &lt;span class="na"&gt;xsi:type=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Linear&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;tpeglinearLocation&amp;gt;&lt;/span&gt;

            &lt;span class="nt"&gt;&amp;lt;to&lt;/span&gt; &lt;span class="na"&gt;xsi:type=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;TPEGNonJunctionPoint&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
              &lt;span class="nt"&gt;&amp;lt;pointCoordinates&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;latitude&amp;gt;&lt;/span&gt;52.51527&lt;span class="nt"&gt;&amp;lt;/latitude&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;longitude&amp;gt;&lt;/span&gt;-1.725507&lt;span class="nt"&gt;&amp;lt;/longitude&amp;gt;&lt;/span&gt;
              &lt;span class="nt"&gt;&amp;lt;/pointCoordinates&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;/to&amp;gt;&lt;/span&gt;

            &lt;span class="nt"&gt;&amp;lt;from&lt;/span&gt; &lt;span class="na"&gt;xsi:type=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;TPEGJunction&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
              &lt;span class="nt"&gt;&amp;lt;pointCoordinates&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;latitude&amp;gt;&lt;/span&gt;52.54374&lt;span class="nt"&gt;&amp;lt;/latitude&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;longitude&amp;gt;&lt;/span&gt;-1.721629&lt;span class="nt"&gt;&amp;lt;/longitude&amp;gt;&lt;/span&gt;
              &lt;span class="nt"&gt;&amp;lt;/pointCoordinates&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;/from&amp;gt;&lt;/span&gt;

          &lt;span class="nt"&gt;&amp;lt;/tpeglinearLocation&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/predefinedLocation&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;/predefinedLocation&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/predefinedLocationSet&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/payloadPublication&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/d2LogicalModel&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Parsing&lt;/h3&gt;
&lt;p&gt;Fetching and parsing this document is the work of a few lines thanks to the Python standard library and &lt;a href="http://lxml.de/"&gt;lxml&lt;/a&gt;'s
&lt;code&gt;objectify&lt;/code&gt; module:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;lxml.objectify&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;parse&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;urllib2&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;urlopen&lt;/span&gt;

&lt;span class="n"&gt;locations_root&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;urlopen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PREDEFINED_LOCATIONS_DOCUMENT_URL&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getroot&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Here I've assumed that you've set the value of &lt;code&gt;PREDEFINED_LOCATIONS_DOCUMENT_URL&lt;/code&gt; to the URL referenced above. (If
you're using Python 3, the &lt;code&gt;urlopen&lt;/code&gt; function has moved into the &lt;code&gt;urllib.request&lt;/code&gt; package.) The &lt;code&gt;objectify&lt;/code&gt; module makes
the contents of the XML file available as attributes on the object. For example, we can get the publication time for the
document in one line. Using the &lt;a href="https://pypi.python.org/pypi/iso8601"&gt;iso8601&lt;/a&gt; package, we can parse it into a standard Python &lt;code&gt;datetime&lt;/code&gt; object:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;journey_time_root&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;payloadPublication&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;publicationTime&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="go"&gt;2013-06-19T14:30:00+01:00&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;iso8601&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;pub_time&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;iso8601&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parse_date&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;journey_time_root&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;payloadPublication&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;publicationTime&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;repr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pub_time&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="go"&gt;datetime.datetime(2013, 6, 19, 14, 30, tzinfo=&amp;lt;FixedOffset &amp;#39;+01:00&amp;#39;&amp;gt;)&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pub_time&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="go"&gt;2013-06-19 14:30:00+01:00&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The &lt;code&gt;objectify&lt;/code&gt; module also exposes lists of elements via a standard Python iterator and so getting a list of all
locations a one-liner:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;locations&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;locations_root&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;payloadPublication&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;predefinedLocationSet&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;predefinedLocation&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We can now easily extract the 'to' and 'from' points for each location. For example, the 'to' element for the location
at index 10 can be pulled out in one print statement:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;to_coord&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;locations&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;predefinedLocation&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;tpeglinearLocation&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pointCoordinates&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tostring&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;to_coord&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pretty_print&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="go"&gt;&amp;lt;pointCoordinates xmlns=&amp;quot;http://datex2.eu/schema/1_0/1_0&amp;quot; xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;&amp;gt;&lt;/span&gt;
&lt;span class="go"&gt;  &amp;lt;latitude&amp;gt;52.51759&amp;lt;/latitude&amp;gt;&lt;/span&gt;
&lt;span class="go"&gt;  &amp;lt;longitude&amp;gt;-1.726274&amp;lt;/longitude&amp;gt;&lt;/span&gt;
&lt;span class="go"&gt;&amp;lt;/pointCoordinates&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We can do the same with the 'from' co-ordinate but note that we have to use a different way to select the 'from' element
since &lt;code&gt;from&lt;/code&gt; is a reserved word in Python:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;from_coord&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;locations&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;predefinedLocation&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;tpeglinearLocation&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;from&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pointCoordinates&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tostring&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;from_coord&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pretty_print&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="go"&gt;&amp;lt;pointCoordinates xmlns=&amp;quot;http://datex2.eu/schema/1_0/1_0&amp;quot; xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;&amp;gt;&lt;/span&gt;
&lt;span class="go"&gt;  &amp;lt;latitude&amp;gt;52.49218&amp;lt;/latitude&amp;gt;&lt;/span&gt;
&lt;span class="go"&gt;  &amp;lt;longitude&amp;gt;-1.715665&amp;lt;/longitude&amp;gt;&lt;/span&gt;
&lt;span class="go"&gt;&amp;lt;/pointCoordinates&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;So, putting it all together, we can write a little helper function which will, given a &lt;code&gt;predefinedLocation&lt;/code&gt; element,
return a pair of longitude, latitude pairs which we can use for plotting later on:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;location_to_lnglat_pair&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;location&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;location&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;predefinedLocation&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;tpeglinearLocation&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;
    &lt;span class="n"&gt;from_&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;location&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;predefinedLocation&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;tpeglinearLocation&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;from&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="n"&gt;to_lnglat&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;float&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pointCoordinates&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;longitude&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="nb"&gt;float&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pointCoordinates&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;latitude&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="n"&gt;from_lnglat&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;float&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;from_&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pointCoordinates&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;longitude&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="nb"&gt;float&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;from_&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pointCoordinates&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;latitude&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;to_lnglat&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;from_lnglat&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We now have a way to get both the location start and end points and also the location's 'id'. This latter value will be
important later on when we want to work out what the current delay is for a particular location.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;location_to_lnglat_pair&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;locations&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt;
&lt;span class="go"&gt;((-1.726274, 52.51759), (-1.715665, 52.49218))&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;locations&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;attrib&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;id&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;span class="go"&gt;Section10976&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Let's arrange the locations into a dictionary. The keys of the dictionary will be the location 'id's and the values
will be the start and end points.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;location_segments&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;dict&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;attrib&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;id&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;location_to_lnglat_pair&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;l&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;locations&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Plotting&lt;/h3&gt;
&lt;p&gt;The matplotlib library has a handy &lt;a href="http://matplotlib.org/api/collections_api.html#matplotlib.collections.LineCollection"&gt;LineCollection&lt;/a&gt; object which can be used to directly plot a set of linear segments
in very few lines:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;matplotlib.pyplt&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;matplotlib.collections&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;LineCollection&lt;/span&gt;

&lt;span class="n"&gt;lc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;LineCollection&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;location_segments&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;values&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;span class="n"&gt;gca&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_collection&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lc&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;axis&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;equal&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="Our first plot of England's roads" src="http://rjw57.github.io/blog/static/images/realtime-traffic-data/figure1.png" /&gt;&lt;/p&gt;
&lt;p&gt;The road network is recognisable there but England appears squashed. That's because the co-ordinates are latitudes and
longitudes. Using these directly to plot a graph is something called the &lt;a href="http://en.wikipedia.org/wiki/Equirectangular"&gt;equirectangular&lt;/a&gt; projection. This projection
isn't usually used for maps of the British Isles since, at our latitude, the projection artifically 'widens' maps making
them look too short and fat. To combat that, maps of England tend to use the &lt;a href="https://en.wikipedia.org/wiki/Ordnance_Survey_National_Grid"&gt;Ordinance Survey National Grid&lt;/a&gt;.
This projection has the advantage of, around England, low distortion and it corresponds to metres East and North of an
origin somewhere off the coast at &lt;a href="http://en.wikipedia.org/wiki/Land%27s_End"&gt;Land's End&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Most common map projections have an 'EPSG' code associated with them. For example, the direct use of latitudes and
longitudes is &lt;a href="http://spatialreference.org/ref/epsg/4326/"&gt;EPSG:4326&lt;/a&gt; and the Ordinance Survey National Grid is &lt;a href="http://spatialreference.org/ref/epsg/27700/"&gt;EPSG:27700&lt;/a&gt;. The Python
&lt;a href="https://pypi.python.org/pypi/GDAL/"&gt;GDAL&lt;/a&gt; library can be used to convert between them:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;osgeo&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;osr&lt;/span&gt;

&lt;span class="n"&gt;bng&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;osr&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SpatialReference&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;bng&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ImportFromEPSG&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;27700&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;wgs84&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;osr&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SpatialReference&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;wgs84&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ImportFromEPSG&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4326&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;wgs84_to_bng&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;osr&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CoordinateTransformation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wgs84&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;bng&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We can convert a location's to and from point to the National Grid using the &lt;code&gt;TransformPoints&lt;/code&gt; method:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wgs84_to_bng&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;TransformPoints&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;location_segments&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;values&lt;/span&gt;&lt;span class="p"&gt;()[&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt;
&lt;span class="go"&gt;[(348854.1132332537, 309682.47213134286, -50.45861489698291), (369860.10673155746, 309570.42095603154,&lt;/span&gt;
&lt;span class="go"&gt;-50.11469571758062)]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Notice that there is a &lt;em&gt;third&lt;/em&gt; co-ordinate returned. This corresponds to the height of the point. We won't use this for
our map and so we'll write a little helper function which strips it off:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;segment_to_bng&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;segment&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;[:&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;wgs84_to_bng&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;TransformPoints&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;segment&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now we can convert a segment straight into the National Grid co-ordinates:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;segment_to_bng&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;location_segments&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;values&lt;/span&gt;&lt;span class="p"&gt;()[&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt;
&lt;span class="go"&gt;[(348854.1132332537, 309682.47213134286), (369860.10673155746, 309570.42095603154)]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Let's use this function to generate a &lt;a href="http://en.wikipedia.org/wiki/Numpy"&gt;NumPy&lt;/a&gt; array object whose rows correspond to
location segments:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;numpy&lt;/span&gt; &lt;span class="kn"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;np&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;segment_coords&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
&lt;span class="gp"&gt;... &lt;/span&gt;  &lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;segment_to_bng&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;location_segments&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;loc&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;loc&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;location_ids&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="gp"&gt;... &lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;segment_coords&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="p"&gt;,:])&lt;/span&gt;
&lt;span class="go"&gt;[[[ 374985.14188095  399376.78814614]&lt;/span&gt;
&lt;span class="go"&gt;  [ 376710.14637564  403171.80369787]]&lt;/span&gt;

&lt;span class="go"&gt; [[ 348854.11323325  309682.47213134]&lt;/span&gt;
&lt;span class="go"&gt;  [ 369860.10673156  309570.42095603]]&lt;/span&gt;

&lt;span class="go"&gt; [[ 392143.39283833  304499.91516244]&lt;/span&gt;
&lt;span class="go"&gt;  [ 396831.4499708   303504.82102035]]]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Using NumPy's slicing syntax, therefore, the co-ordinates of the 'to' point for the location at index 7 will be
&lt;code&gt;segment_coords[7,0,:]&lt;/code&gt; whereas those for the 'from' point for the location at index 10 will be
&lt;code&gt;segment_coords[10,1,:]&lt;/code&gt;. The array itself has three axes:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;segment_coords&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;shape&lt;/span&gt;
&lt;span class="go"&gt;(871, 2, 2)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We can plot these new segments as before:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;lc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;LineCollection&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;segment_coords&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;gca&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_collection&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lc&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;axis&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;equal&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="England's roads on the OSNG" src="http://rjw57.github.io/blog/static/images/realtime-traffic-data/figure2.png" /&gt;&lt;/p&gt;
&lt;p&gt;Notice how the distortion of England is now reduced and, also, that the plot's x- and y-axes are now in metres.&lt;/p&gt;
&lt;h3&gt;Adding a base map underlay&lt;/h3&gt;
&lt;p&gt;It would be nice to get a base map under the road network so that we can orient ourselves with respect to major cities
and the coastline of England. The &lt;a href="http://en.wikipedia.org/wiki/GeoTIFF"&gt;GeoTIFF&lt;/a&gt; format is a variant of the TIFF image
format which can contain information about projection and geographic boundaries. Using my &lt;a href="https://github.com/rjw57/foldbeam"&gt;foldbeam&lt;/a&gt; tool, I've
generated a suitable GeoTIFF which can be &lt;a href="http://rjw57.github.io/blog/static/downloads/england-basemap-osgrid.tiff"&gt;downloaded&lt;/a&gt; from this
website. The GDAL library can also be used to load this image. I'll assume you've downloaded it to a directory and set
the &lt;code&gt;DOWNLOADS_DIR&lt;/code&gt; variable to the path of that directory. Opening the base map image is then very simple indeed:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;os&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;osgeo&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;gdal&lt;/span&gt;

&lt;span class="c"&gt;# DOWNLOADS_DIR is the location of your downloads folder&lt;/span&gt;
&lt;span class="n"&gt;base_map_ds&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;gdal&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;join&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;DOWNLOADS_DIR&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;england-basemap-osgrid.tiff&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The advantage of the GeoTIFF format is that it has encoded within it the numbers required to let us transform between
pixel co-ordinates and projection co-ordinates, in this case the OS National Grid:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;base_map_ds&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;GetGeoTransform&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;span class="go"&gt;(130000.0, 671.2158808933002, 0.0, 700000.0, 0.0, -670.8984375)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We're going to use matplotlib's &lt;code&gt;imshow&lt;/code&gt; function to plot the image. This function takes an &lt;code&gt;extent&lt;/code&gt; parameter which
describes the minimum and maximum x- and  y-co-ordinate for the image. We can calculate this from the numbers stored in
the GeoTIFF:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;origin_x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pixel_size_x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;origin_y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pixel_size_y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;base_map_ds&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;GetGeoTransform&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="c"&gt;# Compute minx, maxx, miny, maxy for image. Notice that, since pixel_size_y is -ve, the miny is not origin_y.&lt;/span&gt;
&lt;span class="n"&gt;base_map_extent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="n"&gt;origin_x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;origin_x&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;pixel_size_x&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;base_map_ds&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;RasterXSize&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;origin_y&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;pixel_size_y&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;base_map_ds&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;RasterYSize&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;origin_y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;An annoying wrinkle is that the &lt;code&gt;imshow&lt;/code&gt; function expects a NumPy three-axis array with the red, green and blue
components of the pixel along the last axis. As you can see, the GeoTIFF format has the red, green, blue and alpha
channel information running along the first axis:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;base_map_ds&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ReadAsArray&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;shape&lt;/span&gt;
&lt;span class="go"&gt;(4, 1024, 806)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;To fix that we use NumPy's &lt;code&gt;transpose&lt;/code&gt; function. Plotting the roads atop the base map is then very simple indeed.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;base_map&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;transpose&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;base_map_ds&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ReadAsArray&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="n"&gt;imshow&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;base_map&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;extent&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;base_map_extent&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;lc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;LineCollection&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;segment_coords&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;gca&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_collection&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lc&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="England's roads with a base map" src="http://rjw57.github.io/blog/static/images/realtime-traffic-data/figure3.png" /&gt;&lt;/p&gt;
&lt;h3&gt;Offsetting each carriageway&lt;/h3&gt;
&lt;p&gt;It isn't obvious from the map above but each link is actually defined twice, once for each carriage way. The difference
is in the ordering of the 'to' and 'from' points. Traffic maps usually offset each carriage way so that both may be
seen. The carriageway is offset, subjectively, to the left since that is the side of the road that we drive on here in
the UK. Although we specify the co-ordinates of each line segment in OS National Grid co-ordinates, we'd like to specify
the offset in figure co-ordinates. These will be either points or pixels depending on the matplotlib backend in use.
Before we can construct a set of 'left' directions for each segment, we need to work out the direction of each segment.
This is simply the 'from' point subtracted from the 'to' point. We also need to normalise these directions to unit
length:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# Compute unit direction of each segment&lt;/span&gt;
&lt;span class="n"&gt;segment_directions&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;segment_coords&lt;/span&gt;&lt;span class="p"&gt;[:,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,:]&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;segment_coords&lt;/span&gt;&lt;span class="p"&gt;[:,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,:]&lt;/span&gt;
&lt;span class="n"&gt;segment_directions&lt;/span&gt; &lt;span class="o"&gt;/=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sqrt&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;segment_directions&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))[&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;newaxis&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The normalising one-liner is a good one to remember here. Once we have a vector pointing along the segment, 'left' is
just this vector rotated 90 degrees anticlockwise. If you remember your high-school geometry, a rotation anticlockwise
by $\theta$ radians can be represented as a multiplication by a matrix:&lt;/p&gt;
&lt;p&gt;$$
\begin{bmatrix}
    x' \\
    y'
\end{bmatrix}
=
\begin{bmatrix}
  \cos \theta &amp;amp; - \sin \theta \\
  \sin \theta &amp;amp; \cos \theta
\end{bmatrix}
\begin{bmatrix}
    x \\
    y
\end{bmatrix}
$$&lt;/p&gt;
&lt;p&gt;Since, for a 90 degree rotation, $\cos \theta = 0$ and $\sin \theta = 1$, computing the 'left' vectors is actually
fairly straight-forward:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;segment_offsets&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;segment_directions&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dot&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;([[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]]))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now we've got these offsets, plotting each segment offset by, in this example, 2 points to the left is only a case of
specifying the offsets to the &lt;code&gt;LineCollection&lt;/code&gt; constructor:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;matplotlib&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;transforms&lt;/span&gt;

&lt;span class="n"&gt;imshow&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;base_map&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;extent&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;base_map_extent&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;lc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;LineCollection&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;segment_coords&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;offsets&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;segment_offsets&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;transOffset&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;transforms&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;IdentityTransform&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;span class="n"&gt;gca&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_collection&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lc&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="England's road network with overlapping roads offset" src="http://rjw57.github.io/blog/static/images/realtime-traffic-data/figure4.png" /&gt;&lt;/p&gt;
&lt;h2&gt;Journey times&lt;/h2&gt;
&lt;p&gt;According to data.gov.uk, &lt;a href="http://hatrafficinfo.dft.gov.uk/feeds/datex/England/JourneyTimeData/content.xml"&gt;the journey time data&lt;/a&gt; is available from the following URL:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;http://hatrafficinfo.dft.gov.uk/feeds/datex/England/JourneyTimeData/content.xml&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;As before we'll consider a simple truncated and commented example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nt"&gt;&amp;lt;d2LogicalModel&lt;/span&gt; &lt;span class="na"&gt;xmlns=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://datex2.eu/schema/1_0/1_0&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;modelBaseVersion=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;1.0&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;payloadPublication&lt;/span&gt; &lt;span class="na"&gt;xmlns:xsi=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;xsi:type=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;ElaboratedDataPublication&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;lang=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;en&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="c"&gt;&amp;lt;!-- The timestamp for this data as an ISO8601 date string. --&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;publicationTime&amp;gt;&lt;/span&gt;2013-06-19T14:19:57+01:00&lt;span class="nt"&gt;&amp;lt;/publicationTime&amp;gt;&lt;/span&gt;

    &lt;span class="c"&gt;&amp;lt;!-- There is one elaboratedData element for each road link --&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;elaboratedData&lt;/span&gt; &lt;span class="na"&gt;id=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;GUID-1768061-10100&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;basicDataValue&lt;/span&gt; &lt;span class="na"&gt;xsi:type=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;TravelTimeValue&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;

        &lt;span class="c"&gt;&amp;lt;!-- The locations of these links are defined elsewhere --&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;affectedLocation&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;locationContainedInGroup&lt;/span&gt; &lt;span class="na"&gt;xsi:type=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;LocationByReference&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;predefinedLocationReference&amp;gt;&lt;/span&gt;Section10100&lt;span class="nt"&gt;&amp;lt;/predefinedLocationReference&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;/locationContainedInGroup&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/affectedLocation&amp;gt;&lt;/span&gt;

        &lt;span class="c"&gt;&amp;lt;!-- These times are in seconds --&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;travelTime&amp;gt;&lt;/span&gt;87.0&lt;span class="nt"&gt;&amp;lt;/travelTime&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;freeFlowTravelTime&amp;gt;&lt;/span&gt;82.0&lt;span class="nt"&gt;&amp;lt;/freeFlowTravelTime&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;normallyExpectedTravelTime&amp;gt;&lt;/span&gt;85.0&lt;span class="nt"&gt;&amp;lt;/normallyExpectedTravelTime&amp;gt;&lt;/span&gt;

      &lt;span class="nt"&gt;&amp;lt;/basicDataValue&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/elaboratedData&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/payloadPublication&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/d2LogicalModel&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Each &lt;code&gt;elaboratedData&lt;/code&gt; element gives the journey times for a single section of road. We can download, parse and extract
these elements in two lines as we did before for the locations database:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;journey_time_root&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;urlopen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;JOURNEY_TIME_DOCUMENT_URL&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getroot&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;journey_time_elems&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;journey_time_root&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;payloadPublication&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;elaboratedData&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Looking at the form of the &lt;code&gt;elaboratedData&lt;/code&gt; element, we can write a little function to return the location 'id' for the
journey and the journey times:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;extract_journey_times&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;datum&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;bdv&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;datum&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;basicDataValue&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="n"&gt;bdv&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;affectedLocation&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;locationContainedInGroup&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;predefinedLocationReference&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;float&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bdv&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;travelTime&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="nb"&gt;float&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bdv&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;freeFlowTravelTime&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="nb"&gt;float&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bdv&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;normallyExpectedTravelTime&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This function returns a value suitable for passing into a &lt;code&gt;dict&lt;/code&gt; constructor:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;extract_journey_times&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;journey_time_elems&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt;
&lt;span class="go"&gt;(&amp;#39;Section10100&amp;#39;, (83.0, 82.0, 86.0))&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;journey_times&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;dict&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;extract_journey_times&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;elem&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;elem&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;journey_time_elems&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now we can use a clever Python list comprehension to generate an array of journey times for each location. Each row with
correspond to a location and the columns correspond to current, free-flow and normally expected travel times in seconds:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;journey_time_data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
  &lt;span class="n"&gt;journey_times&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;loc_id&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;loc_id&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;journey_times&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;nan&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;nan&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;nan&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;loc_id&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;location_ids&lt;/span&gt;
&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Note that if there is no data available for a particular location we fill the row with NaN values. Let's take a look at
the journey times for the first four locations:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;journey_time_data&lt;/span&gt;&lt;span class="p"&gt;[:&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;span class="go"&gt;[[ 269.  235.  266.]&lt;/span&gt;
&lt;span class="go"&gt; [ 413.  336.  407.]&lt;/span&gt;
&lt;span class="go"&gt; [  -1.  289.  332.]&lt;/span&gt;
&lt;span class="go"&gt; [  50.   47.   49.]]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Notice the $-1$ there? That is used to show a 'no result' or 'missing' datum. We can make use of that to construct a
vector of delays in minutes for each link and also an array of flags indicating if a particular link is 'good' or 'bad'.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# Extract the data we want to plot. In this case it is delay time in minutes.&lt;/span&gt;
&lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;journey_time_data&lt;/span&gt;&lt;span class="p"&gt;[:,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;journey_time_data&lt;/span&gt;&lt;span class="p"&gt;[:,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="mi"&gt;60&lt;/span&gt;

&lt;span class="c"&gt;# Find where the &amp;#39;good&amp;#39; (i.e. non-NaN and non-zero) data is&lt;/span&gt;
&lt;span class="n"&gt;good_data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;logical_and&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;isfinite&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;all&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;journey_time_data&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;axis&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Finally we can put all of this together to plot the road network coloured by delay time:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;figure&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;figsize&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="c"&gt;# Plot the base map at 50% opacity over a black background&lt;/span&gt;
&lt;span class="n"&gt;gca&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;set_axis_bgcolor&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="n"&gt;imshow&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;base_map&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;extent&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;base_map_extent&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;alpha&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mf"&gt;0.7&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c"&gt;# Add the line collection which is just the links&lt;/span&gt;
&lt;span class="n"&gt;lc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;LineCollection&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;segment_coords&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;lw&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;white&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;alpha&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mf"&gt;0.2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;gca&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_collection&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lc&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c"&gt;# Add the LineCollection showing bad data&lt;/span&gt;
&lt;span class="n"&gt;lc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;LineCollection&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;segment_coords&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;logical_not&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;good_data&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
    &lt;span class="n"&gt;lw&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;gray&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;offsets&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;segment_offsets&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;logical_not&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;good_data&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;transOffset&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;transforms&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;IdentityTransform&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;span class="n"&gt;gca&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_collection&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lc&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c"&gt;# Add the LineCollection showing good data&lt;/span&gt;
&lt;span class="n"&gt;lc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;LineCollection&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;segment_coords&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;good_data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
    &lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;good_data&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;cmap&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;cm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;RdYlGn_r&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;clim&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;45&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;lw&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;offsets&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;segment_offsets&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;good_data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;transOffset&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;transforms&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;IdentityTransform&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;span class="n"&gt;gca&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_collection&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lc&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c"&gt;# Add a colour bar&lt;/span&gt;
&lt;span class="n"&gt;cb&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;colorbar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;extend&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;both&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;cb&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;set_label&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Delay / minutes&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c"&gt;# Set plot title and label axes&lt;/span&gt;
&lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Travel delays in England on {0}&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pub_time&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;strftime&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt;&lt;span class="si"&gt;%X&lt;/span&gt;&lt;span class="s"&gt;, &lt;/span&gt;&lt;span class="si"&gt;%x&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="c"&gt;# Comment out if you want to have the x- and y- axes labelled&lt;/span&gt;
&lt;span class="n"&gt;gca&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get_xaxis&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;set_visible&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;gca&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get_yaxis&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;set_visible&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="England's road network with journey delays" src="http://rjw57.github.io/blog/static/images/realtime-traffic-data/figure5.png" /&gt;&lt;/p&gt;
&lt;p&gt;You can see at the current time of writing, the road network of the UK is in a pretty good state.&lt;/p&gt;
&lt;h2&gt;Resources&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://rjw57.github.io/blog/static/notebooks/realtime-traffic-data.ipynb"&gt;An IPython notebook with this code in&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="|filename|/downloads/plot-england-traffic-data.py"&gt;The Python script used to generate the image at the top of the post&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;</summary><category term="Python"></category><category term="Friday project"></category><category term="data munging"></category><category term="GIS"></category><category term="matplotlib"></category><category term="data.gov.uk"></category></entry><entry><title>Extracting the GPS traces from Horizon's Secret Life of the Cat</title><link href="http://rjw57.github.io/blog/2013/06/14/extracting-the-gps-traces-from-horizons-secret-life-of-the-cat/" rel="alternate"></link><updated>2013-06-14T00:00:00+02:00</updated><author><name>Rich Wareham</name></author><id>tag:rjw57.github.io/blog,2013-06-14:2013/06/14/extracting-the-gps-traces-from-horizons-secret-life-of-the-cat/</id><summary type="html">&lt;p&gt;&lt;iframe width="100%" height="350" frameborder="0" scrolling="no" marginheight="0" marginwidth="0" src="https://www.google.co.uk/maps/ms?ie=UTF8&amp;amp;hl=en&amp;amp;oe=UTF8&amp;amp;msa=0&amp;amp;msid=205632188049427480820.0004df5bf5bec487c6e14&amp;amp;num=200&amp;amp;ll=51.185315,-0.528953&amp;amp;spn=0.005264,0.01397&amp;amp;t=m&amp;amp;output=embed"&gt;&lt;/iframe&gt;&lt;/p&gt;

&lt;p&gt;The BBC's Horizon programme recently had a special entitled &lt;a href="http://www.bbc.co.uk/programmes/b02xcvhw"&gt;The Secret Life of the Cat&lt;/a&gt; which had an associated
&lt;a href="http://www.bbc.co.uk/news/science-environment-22567526"&gt;interactive map&lt;/a&gt; on
the BBC website. A colleague at work expressed interest in getting the GPS
trace data. The result is &lt;a href="https://github.com/rjw57/secret-life-of-the-cat"&gt;a GitHub repository&lt;/a&gt; with some files in.&lt;/p&gt;
&lt;p&gt;Unfortunately the &lt;a href="http://www.rvc.ac.uk/SML/People/awilson/BBC-Horizon-the-secret-life-of-the-cat.cfm"&gt;research project&lt;/a&gt;
at the Royal Vetinary College does not make the GPS traces available on it's
website. This repository contains my efforts to re-engineer the GPS traces from
the BBC's interactive map. The results can be seen in the &lt;code&gt;geojson/&lt;/code&gt; and &lt;code&gt;kml/&lt;/code&gt;
directories. GitHub now has a direct visualisation feature which means that the
GeoJSON files can be viewed inline on a map.&lt;/p&gt;
&lt;p&gt;In addition, I've uploaded the KML files generated to &lt;a href="https://www.google.co.uk/maps/ms?msid=205632188049427480820.0004df5bf5bec487c6e14&amp;amp;msa=0"&gt;a custom Google map&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;If you want to read the Python code that did the re-projection, the
&lt;a href="http://nbviewer.ipython.org/urls/raw.github.com/rjw57/secret-life-of-the-cat/master/reprojection.ipynb"&gt;web-notebook&lt;/a&gt;
can be viewed online.&lt;/p&gt;
&lt;h2&gt;Scraping the website&lt;/h2&gt;
&lt;p&gt;The excellent Developer Console for Google Chrome revealed that the bulk of the
mapping work on the site was being done in
&lt;a href="http://news.bbcimg.co.uk/news/special/2013/newsspec_5380/js/compiled/desktop/ns_all.js"&gt;one JavaScript file&lt;/a&gt;.
After beautifying this file and poking around for some data, we can find some
JavaScript which creates an object which is in &lt;code&gt;raw-website-data.json&lt;/code&gt; in this
repository.&lt;/p&gt;
&lt;p&gt;This JSON object contains a single array of cat records which itself contains
the traces along with timestamps. Success! Well, not quite. The trace positions
appear to be in pixel co-ordinates on the detail maps. Fail. Well, not quite.
The detail maps themselves are fairly easily exctracted, see the &lt;code&gt;imagery/&lt;/code&gt;
directory. Using my own &lt;a href="https://github.com/rjw57/foldbeam"&gt;foldbeam&lt;/a&gt; program,
I downloaded a GeoTIFF of the Sharnley Green area using the following command:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt; foldbeam-render -p 27700 -l 501000 -r 505000 -b 142000 -t 146000 -w 4000 -o imagery/road.tiff
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This file is available in the &lt;code&gt;imagery/&lt;/code&gt; directory in this repository. It is
the Sarnley Green area. The GeoTIFF is rendered by Foldbeam using OpenStreetMap
tiles but re-projected into the British Ordinance Survey Grid. Using the GIMP,
I then manually aligned the maps as shown in &lt;code&gt;imagery.road.xcf&lt;/code&gt;. Ah, but the
individual map images are of the wrong scale. Luckily if you look at the raw
website data you see that the number of pixels per metre for each map is
recorded. This can be used, as shown in the &lt;code&gt;reprojection.ipynb&lt;/code&gt; IPython web
notebook, to calculate the appropriate scaling for each layer.&lt;/p&gt;
&lt;p&gt;After manual alignment, the location of the maps in the road GeoTIFF is
recorded. Some simple manipulation outlined in &lt;code&gt;reprojection.ipynb&lt;/code&gt; can then be
used to convert pixel locations in the maps to pixel locations in the
OpenStreetMap road image. Since Foldbeam saves a GeoTIFF, we can use the Python
&lt;a href="http://gdal.org/"&gt;GDAL&lt;/a&gt; wrapper to load the road image in and get the
transform from pixel co-ordinates straight into Ordinance Survery grid
co-ordinates.&lt;/p&gt;
&lt;p&gt;We're nearly there. GeoJSON files by default use
&lt;a href="https://en.wikipedia.org/wiki/World_Geodetic_System"&gt;WGS84&lt;/a&gt; latitudes and
longitudes for storing positions. We again use the Python wrappers to transfrom
from one projection to the next. At this point it's a simple job to write out a
little GeoJSON file for each cat.&lt;/p&gt;
&lt;p&gt;The &lt;a href="http://gdal.org/ogr"&gt;OGR&lt;/a&gt; library comes with a handy little utility that
can be used to convert the GeoJSON files into KML files which can be loaded
into Google Earth or onto Google Maps. They're generated by a single command:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt; &lt;span class="k"&gt;for &lt;/span&gt;i in *.geojson; &lt;span class="k"&gt;do &lt;/span&gt;ogr2ogr -f KML ../kml/&lt;span class="sb"&gt;`&lt;/span&gt;basename &lt;span class="nv"&gt;$i&lt;/span&gt; geojson&lt;span class="sb"&gt;`&lt;/span&gt;kml &lt;span class="nv"&gt;$i&lt;/span&gt;; &lt;span class="k"&gt;done&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;And... we're done.&lt;/p&gt;
&lt;h2&gt;Issues&lt;/h2&gt;
&lt;p&gt;Unfortunately, I couldn't work out where Orlando, the cat whose map is an
insert, is based. If anyone wants to send me a pull-request fixing the map
location, I'd be more than happy to accept it.&lt;/p&gt;</summary><category term="GIS"></category><category term="Python"></category><category term="hacking"></category><category term="Friday project"></category><category term="web"></category><category term="data munging"></category></entry></feed>