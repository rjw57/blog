<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>        Processing the UK's real-time traffic data with Python
    </title>
  <meta name="author" content="Rich Wareham">

    <link href="http://rjw57.github.io/blog/feeds/all.atom.xml" type="application/atom+xml" rel="alternate"
        title="Scattered Technologies Atom Feed" />
    
  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link href="http://rjw57.github.io/blog/favicon.png" rel="icon">
  <link href="http://rjw57.github.io/blog/theme/css/main.css" media="screen, projection"
        rel="stylesheet" type="text/css">
  <script src="http://rjw57.github.io/blog/theme/js/modernizr-2.0.js"></script>
  <script src="http://rjw57.github.io/blog/theme/js/ender.js"></script>
  <script src="http://rjw57.github.io/blog/theme/js/octopress.js" type="text/javascript"></script>

  <link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic"
        rel="stylesheet" type="text/css">
  <link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic"
        rel="stylesheet" type="text/css">

  
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
  "HTML-CSS": {
  styles: {
  ".MathJax .mo, .MathJax .mi": {color: "black ! important"}}
  },
  tex2jax: {inlineMath: [['$','$'], ['\(','\)']],processEscapes: true}
  });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>

</head><body>
  <header role="banner"><hgroup>
  <h1><a href="http://rjw57.github.io/blog/">Scattered Technologies</a></h1>
      <h2>Rich Wareham's rambles through interesting things</h2>
  </hgroup></header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="http://rjw57.github.io/blog/feeds/all.atom.xml" rel="subscribe-rss">RSS</a></li>
  </ul>

<!-- TODO: add search here
<form action="" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:http://rjw57.github.io/blog" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
-->

<ul class="main-navigation">
  <li><a href="http://rjw57.github.io/blog/">Blog</a></li>
              <li><a href="http://rjw57.github.io/blog/pages/contact-me.html">Contact Me</a></li>
          <li><a href="http://rjw57.github.io/blog/pages/experiments.html">Experiments</a></li>
          <li><a href="http://rjw57.github.io/blog/pages/old-english.html">Old English</a></li>
        <!-- TODO: add categories here? -->
  </ul></nav>
  <div id="main">
    <div id="content">
      <div>
  <article class="hentry" role="article">
    <header>
          <h1 class="entry-title">Processing the UK's real-time traffic data with Python</h1>
          <p class="meta"><time datetime="2013-06-19T00:00:00" pubdate>Wed 19 June 2013</time></p>
</header>

  <div class="entry-content"><p><img alt="An example traffic map" src="http://rjw57.github.io/blog/static/images/realtime-traffic-data/england-traffic-delays.png" /></p>
<p><em>In this post: parsing the real-time traffic feed from the <a href="http://www.highways.gov.uk/">UK Highways Agency</a>; plotting
the UK's major road links an map using the Ordinance Survey national grid; colouring the result nicely.</em></p>
<p>The UK Government's <a href="http://data.gov.uk/">data.gov.uk</a> website is a treasure-trove of data just waiting to be
downloaded. Recently I started some pre-research on a project at work to do with traffic congestion prediction for which
getting some actual historical data on the state of the roads in the UK would be useful. Luckily the data.gov.uk website
has a section on <a href="http://data.gov.uk/dataset/live-traffic-information-from-the-highways-agency-road-network">live data from the UK Highways Agency</a>. I decided it would be useful to play with
this data and see what I could get out of it.</p>
<h2>What is available</h2>
<p>The data itself takes the form of XML documents which are updated every so often with the current state of the road
network in England. Some files are updated around once every 10 minutes. For example, the UK Highways Agency maintain a
network of <a href="http://en.wikipedia.org/wiki/Automatic_number_plate_recognition">Automatic number plate recognition</a> systems which measure journey times along major links in the UK's
road network. It uses this information to publish three bits of data about each link:</p>
<ul>
<li>the current journey time;</li>
<li>the typical journey time; and</li>
<li>the ideal journey time in free-flowing traffic.</li>
</ul>
<p>It is such data which is used to create traffic delay maps such as the one at the top of this post or
<a href="http://www.trafficengland.com/map.aspx?long0=-128.10065526342794&amp;lat0=3205.4288365561897&amp;long1=119.32156695879439&amp;lat1=3099.8639213019524&amp;ct=true">elsewhere online</a>.</p>
<h2>Road locations</h2>
<p>According to data.gov.uk, <a href="http://hatrafficinfo.dft.gov.uk/feeds/datex/England/PredefinedLocationJourneyTimeSections/content.xml">the location data</a> for journey time data is available from
the following URL:</p>
<blockquote>
<p>http://hatrafficinfo.dft.gov.uk/feeds/datex/England/PredefinedLocationJourneyTimeSections/content.xml</p>
</blockquote>
<p>This document defines a list of <em>locations</em> which, for journey times, are starting and ending points. If we join a line
from the start point to the end point for each location we'll end up with a crude road-map of England.  There is a
corresponding <a href="http://www.datex2.eu/sites/www.datex2.eu/files/NTIS_DATEXII_v2.0_0.pdf">document</a> which describes the schema for this XML document but, for our purposes, it is
sufficient to look at a single truncated and annotated example. I've left out elements which we wont be using.</p>
<div class="highlight"><pre><span class="nt">&lt;d2LogicalModel</span> <span class="na">xmlns=</span><span class="s">&quot;http://datex2.eu/schema/1_0/1_0&quot;</span> <span class="na">modelBaseVersion=</span><span class="s">&quot;1.0&quot;</span><span class="nt">&gt;</span>
  <span class="nt">&lt;payloadPublication</span> <span class="na">xmlns:xsi=</span><span class="s">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>
    <span class="na">xsi:type=</span><span class="s">&quot;PredefinedLocationsPublication&quot;</span> <span class="na">lang=</span><span class="s">&quot;en&quot;</span><span class="nt">&gt;</span>

    <span class="c">&lt;!-- An ISO8601 date for the data --&gt;</span>
    <span class="nt">&lt;publicationTime&gt;</span>2013-06-12T11:59:15+01:00<span class="nt">&lt;/publicationTime&gt;</span>

    <span class="c">&lt;!-- This set of locations is for journey time data --&gt;</span>
    <span class="nt">&lt;predefinedLocationSet</span> <span class="na">id=</span><span class="s">&quot;GUID-NTCC-JourneyTimeSections&quot;</span><span class="nt">&gt;</span>

      <span class="c">&lt;!-- There is one predefinedLocation element for each section of road --&gt;</span>
      <span class="nt">&lt;predefinedLocation</span> <span class="na">id=</span><span class="s">&quot;Section11017&quot;</span><span class="nt">&gt;</span>

        <span class="c">&lt;!-- The road location: a line segment joining a &#39;from&#39; point to a &#39;to&#39; point --&gt;</span>
        <span class="nt">&lt;predefinedLocation</span> <span class="na">xsi:type=</span><span class="s">&quot;Linear&quot;</span><span class="nt">&gt;</span>
          <span class="nt">&lt;tpeglinearLocation&gt;</span>

            <span class="nt">&lt;to</span> <span class="na">xsi:type=</span><span class="s">&quot;TPEGNonJunctionPoint&quot;</span><span class="nt">&gt;</span>
              <span class="nt">&lt;pointCoordinates&gt;</span>
                <span class="nt">&lt;latitude&gt;</span>52.51527<span class="nt">&lt;/latitude&gt;</span>
                <span class="nt">&lt;longitude&gt;</span>-1.725507<span class="nt">&lt;/longitude&gt;</span>
              <span class="nt">&lt;/pointCoordinates&gt;</span>
            <span class="nt">&lt;/to&gt;</span>

            <span class="nt">&lt;from</span> <span class="na">xsi:type=</span><span class="s">&quot;TPEGJunction&quot;</span><span class="nt">&gt;</span>
              <span class="nt">&lt;pointCoordinates&gt;</span>
                <span class="nt">&lt;latitude&gt;</span>52.54374<span class="nt">&lt;/latitude&gt;</span>
                <span class="nt">&lt;longitude&gt;</span>-1.721629<span class="nt">&lt;/longitude&gt;</span>
              <span class="nt">&lt;/pointCoordinates&gt;</span>
            <span class="nt">&lt;/from&gt;</span>

          <span class="nt">&lt;/tpeglinearLocation&gt;</span>
        <span class="nt">&lt;/predefinedLocation&gt;</span>
      <span class="nt">&lt;/predefinedLocation&gt;</span>
    <span class="nt">&lt;/predefinedLocationSet&gt;</span>
  <span class="nt">&lt;/payloadPublication&gt;</span>
<span class="nt">&lt;/d2LogicalModel&gt;</span>
</pre></div>


<h3>Parsing</h3>
<p>Fetching and parsing this document is the work of a few lines thanks to the Python standard library and <a href="http://lxml.de/">lxml</a>'s
<code>objectify</code> module:</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">lxml.objectify</span> <span class="kn">import</span> <span class="n">parse</span>
<span class="kn">from</span> <span class="nn">urllib2</span> <span class="kn">import</span> <span class="n">urlopen</span>

<span class="n">locations_root</span> <span class="o">=</span> <span class="n">parse</span><span class="p">(</span><span class="n">urlopen</span><span class="p">(</span><span class="n">PREDEFINED_LOCATIONS_DOCUMENT_URL</span><span class="p">))</span><span class="o">.</span><span class="n">getroot</span><span class="p">()</span>
</pre></div>


<p>Here I've assumed that you've set the value of <code>PREDEFINED_LOCATIONS_DOCUMENT_URL</code> to the URL referenced above. (If
you're using Python 3, the <code>urlopen</code> function has moved into the <code>urllib.request</code> package.) The <code>objectify</code> module makes
the contents of the XML file available as attributes on the object. For example, we can get the publication time for the
document in one line. Using the <a href="https://pypi.python.org/pypi/iso8601">iso8601</a> package, we can parse it into a standard Python <code>datetime</code> object:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">journey_time_root</span><span class="o">.</span><span class="n">payloadPublication</span><span class="o">.</span><span class="n">publicationTime</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
<span class="go">2013-06-19T14:30:00+01:00</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">iso8601</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pub_time</span> <span class="o">=</span> <span class="n">iso8601</span><span class="o">.</span><span class="n">parse_date</span><span class="p">(</span><span class="n">journey_time_root</span><span class="o">.</span><span class="n">payloadPublication</span><span class="o">.</span><span class="n">publicationTime</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">pub_time</span><span class="p">))</span>
<span class="go">datetime.datetime(2013, 6, 19, 14, 30, tzinfo=&lt;FixedOffset &#39;+01:00&#39;&gt;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">pub_time</span><span class="p">)</span>
<span class="go">2013-06-19 14:30:00+01:00</span>
</pre></div>


<p>The <code>objectify</code> module also exposes lists of elements via a standard Python iterator and so getting a list of all
locations a one-liner:</p>
<div class="highlight"><pre><span class="n">locations</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">locations_root</span><span class="o">.</span><span class="n">payloadPublication</span><span class="o">.</span><span class="n">predefinedLocationSet</span><span class="o">.</span><span class="n">predefinedLocation</span><span class="p">)</span>
</pre></div>


<p>We can now easily extract the 'to' and 'from' points for each location. For example, the 'to' element for the location
at index 10 can be pulled out in one print statement:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">to_coord</span> <span class="o">=</span> <span class="n">locations</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="o">.</span><span class="n">predefinedLocation</span><span class="o">.</span><span class="n">tpeglinearLocation</span><span class="o">.</span><span class="n">to</span><span class="o">.</span><span class="n">pointCoordinates</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">tostring</span><span class="p">(</span><span class="n">to_coord</span><span class="p">,</span> <span class="n">pretty_print</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
<span class="go">&lt;pointCoordinates xmlns=&quot;http://datex2.eu/schema/1_0/1_0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&gt;</span>
<span class="go">  &lt;latitude&gt;52.51759&lt;/latitude&gt;</span>
<span class="go">  &lt;longitude&gt;-1.726274&lt;/longitude&gt;</span>
<span class="go">&lt;/pointCoordinates&gt;</span>
</pre></div>


<p>We can do the same with the 'from' co-ordinate but note that we have to use a different way to select the 'from' element
since <code>from</code> is a reserved word in Python:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">from_coord</span> <span class="o">=</span> <span class="n">locations</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="o">.</span><span class="n">predefinedLocation</span><span class="o">.</span><span class="n">tpeglinearLocation</span><span class="p">[</span><span class="s">&#39;from&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">pointCoordinates</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">tostring</span><span class="p">(</span><span class="n">from_coord</span><span class="p">,</span> <span class="n">pretty_print</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
<span class="go">&lt;pointCoordinates xmlns=&quot;http://datex2.eu/schema/1_0/1_0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&gt;</span>
<span class="go">  &lt;latitude&gt;52.49218&lt;/latitude&gt;</span>
<span class="go">  &lt;longitude&gt;-1.715665&lt;/longitude&gt;</span>
<span class="go">&lt;/pointCoordinates&gt;</span>
</pre></div>


<p>So, putting it all together, we can write a little helper function which will, given a <code>predefinedLocation</code> element,
return a pair of longitude, latitude pairs which we can use for plotting later on:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">location_to_lnglat_pair</span><span class="p">(</span><span class="n">location</span><span class="p">):</span>
    <span class="n">to</span> <span class="o">=</span> <span class="n">location</span><span class="o">.</span><span class="n">predefinedLocation</span><span class="o">.</span><span class="n">tpeglinearLocation</span><span class="o">.</span><span class="n">to</span>
    <span class="n">from_</span> <span class="o">=</span> <span class="n">location</span><span class="o">.</span><span class="n">predefinedLocation</span><span class="o">.</span><span class="n">tpeglinearLocation</span><span class="p">[</span><span class="s">&#39;from&#39;</span><span class="p">]</span>
    <span class="n">to_lnglat</span> <span class="o">=</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">to</span><span class="o">.</span><span class="n">pointCoordinates</span><span class="o">.</span><span class="n">longitude</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">to</span><span class="o">.</span><span class="n">pointCoordinates</span><span class="o">.</span><span class="n">latitude</span><span class="p">))</span>
    <span class="n">from_lnglat</span> <span class="o">=</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">from_</span><span class="o">.</span><span class="n">pointCoordinates</span><span class="o">.</span><span class="n">longitude</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">from_</span><span class="o">.</span><span class="n">pointCoordinates</span><span class="o">.</span><span class="n">latitude</span><span class="p">))</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">to_lnglat</span><span class="p">,</span> <span class="n">from_lnglat</span><span class="p">)</span>
</pre></div>


<p>We now have a way to get both the location start and end points and also the location's 'id'. This latter value will be
important later on when we want to work out what the current delay is for a particular location.</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">location_to_lnglat_pair</span><span class="p">(</span><span class="n">locations</span><span class="p">[</span><span class="mi">10</span><span class="p">]))</span>
<span class="go">((-1.726274, 52.51759), (-1.715665, 52.49218))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">locations</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;id&#39;</span><span class="p">])</span>
<span class="go">Section10976</span>
</pre></div>


<p>Let's arrange the locations into a dictionary. The keys of the dictionary will be the location 'id's and the values
will be the start and end points.</p>
<div class="highlight"><pre><span class="n">location_segments</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">l</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;id&#39;</span><span class="p">],</span> <span class="n">location_to_lnglat_pair</span><span class="p">(</span><span class="n">l</span><span class="p">))</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">locations</span><span class="p">)</span>
</pre></div>


<h3>Plotting</h3>
<p>The matplotlib library has a handy <a href="http://matplotlib.org/api/collections_api.html#matplotlib.collections.LineCollection">LineCollection</a> object which can be used to directly plot a set of linear segments
in very few lines:</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">matplotlib.pyplt</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">matplotlib.collections</span> <span class="kn">import</span> <span class="n">LineCollection</span>

<span class="n">lc</span> <span class="o">=</span> <span class="n">LineCollection</span><span class="p">(</span><span class="n">location_segments</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
<span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">lc</span><span class="p">)</span>
<span class="n">axis</span><span class="p">(</span><span class="s">&#39;equal&#39;</span><span class="p">)</span>
</pre></div>


<p><img alt="Our first plot of England's roads" src="http://rjw57.github.io/blog/static/images/realtime-traffic-data/figure1.png" /></p>
<p>The road network is recognisable there but England appears squashed. That's because the co-ordinates are latitudes and
longitudes. Using these directly to plot a graph is something called the <a href="http://en.wikipedia.org/wiki/Equirectangular">equirectangular</a> projection. This projection
isn't usually used for maps of the British Isles since, at our latitude, the projection artifically 'widens' maps making
them look too short and fat. To combat that, maps of England tend to use the <a href="https://en.wikipedia.org/wiki/Ordnance_Survey_National_Grid">Ordinance Survey National Grid</a>.
This projection has the advantage of, around England, low distortion and it corresponds to metres East and North of an
origin somewhere off the coast at <a href="http://en.wikipedia.org/wiki/Land%27s_End">Land's End</a>.</p>
<p>Most common map projections have an 'EPSG' code associated with them. For example, the direct use of latitudes and
longitudes is <a href="http://spatialreference.org/ref/epsg/4326/">EPSG:4326</a> and the Ordinance Survey National Grid is <a href="http://spatialreference.org/ref/epsg/27700/">EPSG:27700</a>. The Python
<a href="https://pypi.python.org/pypi/GDAL/">GDAL</a> library can be used to convert between them:</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">osgeo</span> <span class="kn">import</span> <span class="n">osr</span>

<span class="n">bng</span> <span class="o">=</span> <span class="n">osr</span><span class="o">.</span><span class="n">SpatialReference</span><span class="p">()</span>
<span class="n">bng</span><span class="o">.</span><span class="n">ImportFromEPSG</span><span class="p">(</span><span class="mi">27700</span><span class="p">)</span>

<span class="n">wgs84</span> <span class="o">=</span> <span class="n">osr</span><span class="o">.</span><span class="n">SpatialReference</span><span class="p">()</span>
<span class="n">wgs84</span><span class="o">.</span><span class="n">ImportFromEPSG</span><span class="p">(</span><span class="mi">4326</span><span class="p">)</span>

<span class="n">wgs84_to_bng</span> <span class="o">=</span> <span class="n">osr</span><span class="o">.</span><span class="n">CoordinateTransformation</span><span class="p">(</span><span class="n">wgs84</span><span class="p">,</span> <span class="n">bng</span><span class="p">)</span>
</pre></div>


<p>We can convert a location's to and from point to the National Grid using the <code>TransformPoints</code> method:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">wgs84_to_bng</span><span class="o">.</span><span class="n">TransformPoints</span><span class="p">(</span><span class="n">location_segments</span><span class="o">.</span><span class="n">values</span><span class="p">()[</span><span class="mi">10</span><span class="p">]))</span>
<span class="go">[(348854.1132332537, 309682.47213134286, -50.45861489698291), (369860.10673155746, 309570.42095603154,</span>
<span class="go">-50.11469571758062)]</span>
</pre></div>


<p>Notice that there is a <em>third</em> co-ordinate returned. This corresponds to the height of the point. We won't use this for
our map and so we'll write a little helper function which strips it off:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">segment_to_bng</span><span class="p">(</span><span class="n">segment</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">wgs84_to_bng</span><span class="o">.</span><span class="n">TransformPoints</span><span class="p">(</span><span class="n">segment</span><span class="p">))</span>
</pre></div>


<p>Now we can convert a segment straight into the National Grid co-ordinates:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">segment_to_bng</span><span class="p">(</span><span class="n">location_segments</span><span class="o">.</span><span class="n">values</span><span class="p">()[</span><span class="mi">10</span><span class="p">]))</span>
<span class="go">[(348854.1132332537, 309682.47213134286), (369860.10673155746, 309570.42095603154)]</span>
</pre></div>


<p>Let's use this function to generate a <a href="http://en.wikipedia.org/wiki/Numpy">NumPy</a> array object whose rows correspond to
location segments:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">segment_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
<span class="gp">... </span>  <span class="nb">list</span><span class="p">(</span><span class="n">segment_to_bng</span><span class="p">(</span><span class="n">location_segments</span><span class="p">[</span><span class="n">loc</span><span class="p">])</span> <span class="k">for</span> <span class="n">loc</span> <span class="ow">in</span> <span class="n">location_ids</span><span class="p">)</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">segment_coords</span><span class="p">[</span><span class="mi">9</span><span class="p">:</span><span class="mi">12</span><span class="p">,:])</span>
<span class="go">[[[ 374985.14188095  399376.78814614]</span>
<span class="go">  [ 376710.14637564  403171.80369787]]</span>

<span class="go"> [[ 348854.11323325  309682.47213134]</span>
<span class="go">  [ 369860.10673156  309570.42095603]]</span>

<span class="go"> [[ 392143.39283833  304499.91516244]</span>
<span class="go">  [ 396831.4499708   303504.82102035]]]</span>
</pre></div>


<p>Using NumPy's slicing syntax, therefore, the co-ordinates of the 'to' point for the location at index 7 will be
<code>segment_coords[7,0,:]</code> whereas those for the 'from' point for the location at index 10 will be
<code>segment_coords[10,1,:]</code>. The array itself has three axes:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">segment_coords</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(871, 2, 2)</span>
</pre></div>


<p>We can plot these new segments as before:</p>
<div class="highlight"><pre><span class="n">lc</span> <span class="o">=</span> <span class="n">LineCollection</span><span class="p">(</span><span class="n">segment_coords</span><span class="p">)</span>
<span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">lc</span><span class="p">)</span>
<span class="n">axis</span><span class="p">(</span><span class="s">&#39;equal&#39;</span><span class="p">)</span>
</pre></div>


<p><img alt="England's roads on the OSNG" src="http://rjw57.github.io/blog/static/images/realtime-traffic-data/figure2.png" /></p>
<p>Notice how the distortion of England is now reduced and, also, that the plot's x- and y-axes are now in metres.</p>
<h3>Adding a base map underlay</h3>
<p>It would be nice to get a base map under the road network so that we can orient ourselves with respect to major cities
and the coastline of England. The <a href="http://en.wikipedia.org/wiki/GeoTIFF">GeoTIFF</a> format is a variant of the TIFF image
format which can contain information about projection and geographic boundaries. Using my <a href="https://github.com/rjw57/foldbeam">foldbeam</a> tool, I've
generated a suitable GeoTIFF which can be <a href="http://rjw57.github.io/blog/static/downloads/england-basemap-osgrid.tiff">downloaded</a> from this
website. The GDAL library can also be used to load this image. I'll assume you've downloaded it to a directory and set
the <code>DOWNLOADS_DIR</code> variable to the path of that directory. Opening the base map image is then very simple indeed:</p>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">osgeo</span> <span class="kn">import</span> <span class="n">gdal</span>

<span class="c"># DOWNLOADS_DIR is the location of your downloads folder</span>
<span class="n">base_map_ds</span> <span class="o">=</span> <span class="n">gdal</span><span class="o">.</span><span class="n">Open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">DOWNLOADS_DIR</span><span class="p">,</span> <span class="s">&#39;england-basemap-osgrid.tiff&#39;</span><span class="p">))</span>
</pre></div>


<p>The advantage of the GeoTIFF format is that it has encoded within it the numbers required to let us transform between
pixel co-ordinates and projection co-ordinates, in this case the OS National Grid:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">base_map_ds</span><span class="o">.</span><span class="n">GetGeoTransform</span><span class="p">())</span>
<span class="go">(130000.0, 671.2158808933002, 0.0, 700000.0, 0.0, -670.8984375)</span>
</pre></div>


<p>We're going to use matplotlib's <code>imshow</code> function to plot the image. This function takes an <code>extent</code> parameter which
describes the minimum and maximum x- and  y-co-ordinate for the image. We can calculate this from the numbers stored in
the GeoTIFF:</p>
<div class="highlight"><pre><span class="n">origin_x</span><span class="p">,</span> <span class="n">pixel_size_x</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">origin_y</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">pixel_size_y</span> <span class="o">=</span> <span class="n">base_map_ds</span><span class="o">.</span><span class="n">GetGeoTransform</span><span class="p">()</span>

<span class="c"># Compute minx, maxx, miny, maxy for image. Notice that, since pixel_size_y is -ve, the miny is not origin_y.</span>
<span class="n">base_map_extent</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">origin_x</span><span class="p">,</span> <span class="n">origin_x</span> <span class="o">+</span> <span class="n">pixel_size_x</span> <span class="o">*</span> <span class="n">base_map_ds</span><span class="o">.</span><span class="n">RasterXSize</span><span class="p">,</span>
    <span class="n">origin_y</span> <span class="o">+</span> <span class="n">pixel_size_y</span> <span class="o">*</span> <span class="n">base_map_ds</span><span class="o">.</span><span class="n">RasterYSize</span><span class="p">,</span> <span class="n">origin_y</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>


<p>An annoying wrinkle is that the <code>imshow</code> function expects a NumPy three-axis array with the red, green and blue
components of the pixel along the last axis. As you can see, the GeoTIFF format has the red, green, blue and alpha
channel information running along the first axis:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">base_map_ds</span><span class="o">.</span><span class="n">ReadAsArray</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(4, 1024, 806)</span>
</pre></div>


<p>To fix that we use NumPy's <code>transpose</code> function. Plotting the roads atop the base map is then very simple indeed.</p>
<div class="highlight"><pre><span class="n">base_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">base_map_ds</span><span class="o">.</span><span class="n">ReadAsArray</span><span class="p">(),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
<span class="n">imshow</span><span class="p">(</span><span class="n">base_map</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="n">base_map_extent</span><span class="p">)</span>
<span class="n">lc</span> <span class="o">=</span> <span class="n">LineCollection</span><span class="p">(</span><span class="n">segment_coords</span><span class="p">)</span>
<span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">lc</span><span class="p">)</span>
</pre></div>


<p><img alt="England's roads with a base map" src="http://rjw57.github.io/blog/static/images/realtime-traffic-data/figure3.png" /></p>
<h3>Offsetting each carriageway</h3>
<p>It isn't obvious from the map above but each link is actually defined twice, once for each carriage way. The difference
is in the ordering of the 'to' and 'from' points. Traffic maps usually offset each carriage way so that both may be
seen. The carriageway is offset, subjectively, to the left since that is the side of the road that we drive on here in
the UK. Although we specify the co-ordinates of each line segment in OS National Grid co-ordinates, we'd like to specify
the offset in figure co-ordinates. These will be either points or pixels depending on the matplotlib backend in use.
Before we can construct a set of 'left' directions for each segment, we need to work out the direction of each segment.
This is simply the 'from' point subtracted from the 'to' point. We also need to normalise these directions to unit
length:</p>
<div class="highlight"><pre><span class="c"># Compute unit direction of each segment</span>
<span class="n">segment_directions</span> <span class="o">=</span> <span class="n">segment_coords</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">-</span> <span class="n">segment_coords</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,:]</span>
<span class="n">segment_directions</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">segment_directions</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
</pre></div>


<p>The normalising one-liner is a good one to remember here. Once we have a vector pointing along the segment, 'left' is
just this vector rotated 90 degrees anticlockwise. If you remember your high-school geometry, a rotation anticlockwise
by $\theta$ radians can be represented as a multiplication by a matrix:</p>
<p>$$
\begin{bmatrix}
    x' \\
    y'
\end{bmatrix}
=
\begin{bmatrix}
  \cos \theta &amp; - \sin \theta \\
  \sin \theta &amp; \cos \theta
\end{bmatrix}
\begin{bmatrix}
    x \\
    y
\end{bmatrix}
$$</p>
<p>Since, for a 90 degree rotation, $\cos \theta = 0$ and $\sin \theta = 1$, computing the 'left' vectors is actually
fairly straight-forward:</p>
<div class="highlight"><pre><span class="n">segment_offsets</span> <span class="o">=</span> <span class="n">segment_directions</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]))</span>
</pre></div>


<p>Now we've got these offsets, plotting each segment offset by, in this example, 2 points to the left is only a case of
specifying the offsets to the <code>LineCollection</code> constructor:</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">transforms</span>

<span class="n">imshow</span><span class="p">(</span><span class="n">base_map</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="n">base_map_extent</span><span class="p">)</span>
<span class="n">lc</span> <span class="o">=</span> <span class="n">LineCollection</span><span class="p">(</span><span class="n">segment_coords</span><span class="p">,</span>
    <span class="n">offsets</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">segment_offsets</span><span class="p">,</span> <span class="n">transOffset</span><span class="o">=</span><span class="n">transforms</span><span class="o">.</span><span class="n">IdentityTransform</span><span class="p">())</span>
<span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">lc</span><span class="p">)</span>
</pre></div>


<p><img alt="England's road network with overlapping roads offset" src="http://rjw57.github.io/blog/static/images/realtime-traffic-data/figure4.png" /></p>
<h2>Journey times</h2>
<p>According to data.gov.uk, <a href="http://hatrafficinfo.dft.gov.uk/feeds/datex/England/JourneyTimeData/content.xml">the journey time data</a> is available from the following URL:</p>
<blockquote>
<p>http://hatrafficinfo.dft.gov.uk/feeds/datex/England/JourneyTimeData/content.xml</p>
</blockquote>
<p>As before we'll consider a simple truncated and commented example:</p>
<div class="highlight"><pre><span class="nt">&lt;d2LogicalModel</span> <span class="na">xmlns=</span><span class="s">&quot;http://datex2.eu/schema/1_0/1_0&quot;</span> <span class="na">modelBaseVersion=</span><span class="s">&quot;1.0&quot;</span><span class="nt">&gt;</span>
  <span class="nt">&lt;payloadPublication</span> <span class="na">xmlns:xsi=</span><span class="s">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="na">xsi:type=</span><span class="s">&quot;ElaboratedDataPublication&quot;</span> <span class="na">lang=</span><span class="s">&quot;en&quot;</span><span class="nt">&gt;</span>
    <span class="c">&lt;!-- The timestamp for this data as an ISO8601 date string. --&gt;</span>
    <span class="nt">&lt;publicationTime&gt;</span>2013-06-19T14:19:57+01:00<span class="nt">&lt;/publicationTime&gt;</span>

    <span class="c">&lt;!-- There is one elaboratedData element for each road link --&gt;</span>
    <span class="nt">&lt;elaboratedData</span> <span class="na">id=</span><span class="s">&quot;GUID-1768061-10100&quot;</span><span class="nt">&gt;</span>
      <span class="nt">&lt;basicDataValue</span> <span class="na">xsi:type=</span><span class="s">&quot;TravelTimeValue&quot;</span><span class="nt">&gt;</span>

        <span class="c">&lt;!-- The locations of these links are defined elsewhere --&gt;</span>
        <span class="nt">&lt;affectedLocation&gt;</span>
          <span class="nt">&lt;locationContainedInGroup</span> <span class="na">xsi:type=</span><span class="s">&quot;LocationByReference&quot;</span><span class="nt">&gt;</span>
            <span class="nt">&lt;predefinedLocationReference&gt;</span>Section10100<span class="nt">&lt;/predefinedLocationReference&gt;</span>
          <span class="nt">&lt;/locationContainedInGroup&gt;</span>
        <span class="nt">&lt;/affectedLocation&gt;</span>

        <span class="c">&lt;!-- These times are in seconds --&gt;</span>
        <span class="nt">&lt;travelTime&gt;</span>87.0<span class="nt">&lt;/travelTime&gt;</span>
        <span class="nt">&lt;freeFlowTravelTime&gt;</span>82.0<span class="nt">&lt;/freeFlowTravelTime&gt;</span>
        <span class="nt">&lt;normallyExpectedTravelTime&gt;</span>85.0<span class="nt">&lt;/normallyExpectedTravelTime&gt;</span>

      <span class="nt">&lt;/basicDataValue&gt;</span>
    <span class="nt">&lt;/elaboratedData&gt;</span>
  <span class="nt">&lt;/payloadPublication&gt;</span>
<span class="nt">&lt;/d2LogicalModel&gt;</span>
</pre></div>


<p>Each <code>elaboratedData</code> element gives the journey times for a single section of road. We can download, parse and extract
these elements in two lines as we did before for the locations database:</p>
<div class="highlight"><pre><span class="n">journey_time_root</span> <span class="o">=</span> <span class="n">parse</span><span class="p">(</span><span class="n">urlopen</span><span class="p">(</span><span class="n">JOURNEY_TIME_DOCUMENT_URL</span><span class="p">))</span><span class="o">.</span><span class="n">getroot</span><span class="p">()</span>
<span class="n">journey_time_elems</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">journey_time_root</span><span class="o">.</span><span class="n">payloadPublication</span><span class="o">.</span><span class="n">elaboratedData</span><span class="p">)</span>
</pre></div>


<p>Looking at the form of the <code>elaboratedData</code> element, we can write a little function to return the location 'id' for the
journey and the journey times:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">extract_journey_times</span><span class="p">(</span><span class="n">datum</span><span class="p">):</span>
    <span class="n">bdv</span> <span class="o">=</span> <span class="n">datum</span><span class="o">.</span><span class="n">basicDataValue</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="n">bdv</span><span class="o">.</span><span class="n">affectedLocation</span><span class="o">.</span><span class="n">locationContainedInGroup</span><span class="o">.</span><span class="n">predefinedLocationReference</span><span class="o">.</span><span class="n">text</span><span class="p">,</span>
        <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">bdv</span><span class="o">.</span><span class="n">travelTime</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">bdv</span><span class="o">.</span><span class="n">freeFlowTravelTime</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">bdv</span><span class="o">.</span><span class="n">normallyExpectedTravelTime</span><span class="p">))</span>
    <span class="p">)</span>
</pre></div>


<p>This function returns a value suitable for passing into a <code>dict</code> constructor:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">extract_journey_times</span><span class="p">(</span><span class="n">journey_time_elems</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
<span class="go">(&#39;Section10100&#39;, (83.0, 82.0, 86.0))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">journey_times</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">extract_journey_times</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">journey_time_elems</span><span class="p">)</span>
</pre></div>


<p>Now we can use a clever Python list comprehension to generate an array of journey times for each location. Each row with
correspond to a location and the columns correspond to current, free-flow and normally expected travel times in seconds:</p>
<div class="highlight"><pre><span class="n">journey_time_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span>
  <span class="n">journey_times</span><span class="p">[</span><span class="n">loc_id</span><span class="p">]</span> <span class="k">if</span> <span class="n">loc_id</span> <span class="ow">in</span> <span class="n">journey_times</span> <span class="k">else</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">loc_id</span> <span class="ow">in</span> <span class="n">location_ids</span>
<span class="p">))</span>
</pre></div>


<p>Note that if there is no data available for a particular location we fill the row with NaN values. Let's take a look at
the journey times for the first four locations:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">journey_time_data</span><span class="p">[:</span><span class="mi">4</span><span class="p">,</span><span class="o">...</span><span class="p">])</span>
<span class="go">[[ 269.  235.  266.]</span>
<span class="go"> [ 413.  336.  407.]</span>
<span class="go"> [  -1.  289.  332.]</span>
<span class="go"> [  50.   47.   49.]]</span>
</pre></div>


<p>Notice the $-1$ there? That is used to show a 'no result' or 'missing' datum. We can make use of that to construct a
vector of delays in minutes for each link and also an array of flags indicating if a particular link is 'good' or 'bad'.</p>
<div class="highlight"><pre><span class="c"># Extract the data we want to plot. In this case it is delay time in minutes.</span>
<span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="n">journey_time_data</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">journey_time_data</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="mi">60</span>

<span class="c"># Find where the &#39;good&#39; (i.e. non-NaN and non-zero) data is</span>
<span class="n">good_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">journey_time_data</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
</pre></div>


<p>Finally we can put all of this together to plot the road network coloured by delay time:</p>
<div class="highlight"><pre><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>

<span class="c"># Plot the base map at 50% opacity over a black background</span>
<span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">set_axis_bgcolor</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
<span class="n">imshow</span><span class="p">(</span><span class="n">base_map</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="n">base_map_extent</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>

<span class="c"># Add the line collection which is just the links</span>
<span class="n">lc</span> <span class="o">=</span> <span class="n">LineCollection</span><span class="p">(</span><span class="n">segment_coords</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">&#39;white&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>
<span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">lc</span><span class="p">)</span>

<span class="c"># Add the LineCollection showing bad data</span>
<span class="n">lc</span> <span class="o">=</span> <span class="n">LineCollection</span><span class="p">(</span><span class="n">segment_coords</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">good_data</span><span class="p">),</span><span class="o">...</span><span class="p">],</span>
    <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">&#39;gray&#39;</span><span class="p">,</span>
    <span class="n">offsets</span><span class="o">=</span><span class="mi">3</span><span class="o">*</span><span class="n">segment_offsets</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">good_data</span><span class="p">),</span><span class="o">...</span><span class="p">],</span> <span class="n">transOffset</span><span class="o">=</span><span class="n">transforms</span><span class="o">.</span><span class="n">IdentityTransform</span><span class="p">())</span>
<span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">lc</span><span class="p">)</span>

<span class="c"># Add the LineCollection showing good data</span>
<span class="n">lc</span> <span class="o">=</span> <span class="n">LineCollection</span><span class="p">(</span><span class="n">segment_coords</span><span class="p">[</span><span class="n">good_data</span><span class="p">,</span><span class="o">...</span><span class="p">],</span>
    <span class="n">array</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="n">good_data</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cm</span><span class="o">.</span><span class="n">RdYlGn_r</span><span class="p">,</span> <span class="n">clim</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">45</span><span class="p">),</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">offsets</span><span class="o">=</span><span class="mi">3</span><span class="o">*</span><span class="n">segment_offsets</span><span class="p">[</span><span class="n">good_data</span><span class="p">,</span><span class="o">...</span><span class="p">],</span> <span class="n">transOffset</span><span class="o">=</span><span class="n">transforms</span><span class="o">.</span><span class="n">IdentityTransform</span><span class="p">())</span>
<span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">lc</span><span class="p">)</span>

<span class="c"># Add a colour bar</span>
<span class="n">cb</span> <span class="o">=</span> <span class="n">colorbar</span><span class="p">(</span><span class="n">lc</span><span class="p">,</span> <span class="n">extend</span><span class="o">=</span><span class="s">&#39;both&#39;</span><span class="p">)</span>
<span class="n">cb</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="s">&#39;Delay / minutes&#39;</span><span class="p">)</span>

<span class="c"># Set plot title and label axes</span>
<span class="n">title</span><span class="p">(</span><span class="s">&#39;Travel delays in England on {0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pub_time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%X</span><span class="s">, </span><span class="si">%x</span><span class="s">&#39;</span><span class="p">)))</span>

<span class="c"># Comment out if you want to have the x- and y- axes labelled</span>
<span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">get_xaxis</span><span class="p">()</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">get_yaxis</span><span class="p">()</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
</pre></div>


<p><img alt="England's road network with journey delays" src="http://rjw57.github.io/blog/static/images/realtime-traffic-data/figure5.png" /></p>
<p>You can see at the current time of writing, the road network of the UK is in a pretty good state.</p>
<h2>Resources</h2>
<ul>
<li><a href="http://rjw57.github.io/blog/static/notebooks/realtime-traffic-data.ipynb">An IPython notebook with this code in</a>.</li>
<li><a href="http://rjw57.github.io/blog/static/downloads/plot-england-traffic-delays.py">The Python script used to generate the image at the top of the post</a>.</li>
</ul></div>
    <footer>
      <p class="meta">
  <span class="byline author vcard">
    Posted by <span class="fn">Rich Wareham</span>
  </span>
  <time datetime="2013-06-19T00:00:00" pubdate>Wed 19 June 2013</time>    <span class="categories">
        <a class="category" href="http://rjw57.github.io/blog/tag/python.html">Python</a>
        <a class="category" href="http://rjw57.github.io/blog/tag/friday-project.html">Friday project</a>
        <a class="category" href="http://rjw57.github.io/blog/tag/data-munging.html">data munging</a>
        <a class="category" href="http://rjw57.github.io/blog/tag/gis.html">GIS</a>
        <a class="category" href="http://rjw57.github.io/blog/tag/matplotlib.html">matplotlib</a>
        <a class="category" href="http://rjw57.github.io/blog/tag/datagovuk.html">data.gov.uk</a>
      </span>
  </p>      <div class="sharing">
    <a href="http://twitter.com/share" class="twitter-share-button" data-url="http://rjw57.github.io/blog/2013/06/19/real-time-traffic-data/" data-via="richwareham" data-counturl="http://rjw57.github.io/blog/2013/06/19/real-time-traffic-data/" >Tweet</a>
      <div class="g-plusone" data-size="medium"></div>
    </div>    </footer>
  </article>

    <section>
    <h1>Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div>
  </section>
  </div>
      <aside class="sidebar">
  <section>
    <h1>Recent Posts</h1>
    <ul id="recent_posts">
            <li class="post">
          <a href="http://rjw57.github.io/blog/2013/06/19/real-time-traffic-data/">Processing the UK's real-time traffic data with Python</a>
      </li>
            <li class="post">
          <a href="http://rjw57.github.io/blog/2013/06/14/extracting-the-gps-traces-from-horizons-secret-life-of-the-cat/">Extracting the GPS traces from Horizon's Secret Life of the Cat</a>
      </li>
          </ul>
  </section>
    <section>
      
    <h1>Categories</h1>
    <ul id="recent_posts">
              <li><a href="http://rjw57.github.io/blog/category/gis.html">GIS</a></li>
          </ul>
  </section>
   

  <section>
  <h1>Tags</h1>
      <a href="http://rjw57.github.io/blog/tag/web.html">web</a>,      <a href="http://rjw57.github.io/blog/tag/datagovuk.html">data.gov.uk</a>,      <a href="http://rjw57.github.io/blog/tag/friday-project.html">Friday project</a>,      <a href="http://rjw57.github.io/blog/tag/python.html">Python</a>,      <a href="http://rjw57.github.io/blog/tag/matplotlib.html">matplotlib</a>,      <a href="http://rjw57.github.io/blog/tag/data-munging.html">data munging</a>,      <a href="http://rjw57.github.io/blog/tag/gis.html">GIS</a>,      <a href="http://rjw57.github.io/blog/tag/hacking.html">hacking</a>    </section>

  
                    
  <section>
    <h1>GitHub Repos</h1>
    <ul id="gh_repos">
      <li class="loading">Status updating...</li>
    </ul>
          <a href="https://github.com/rjw57">@rjw57</a> on GitHub
        <script type="text/javascript">
      $.domReady(function(){
          if (!window.jXHR){
              var jxhr = document.createElement('script');
              jxhr.type = 'text/javascript';
              jxhr.src = 'http://rjw57.github.io/blog/theme/js/jXHR.js';
              var s = document.getElementsByTagName('script')[0];
              s.parentNode.insertBefore(jxhr, s);
          }

          github.showRepos({
              user: 'rjw57',
              count: 3,
              skip_forks: true,
              target: '#gh_repos'
          });
      });
    </script>
    <script src="http://rjw57.github.io/blog/theme/js/github.js" type="text/javascript"> </script>
  </section>
  
    <section>
        <a href="http://twitter.com/richwareham" class="twitter-follow-button" data-show-count="true">Follow @richwareham</a>
  </section>
  <section class="googleplus">
  <h1>
    <a href="https://plus.google.com/114005052144439249039?rel=author">
      <img src="http://www.google.com/images/icons/ui/gprofile_button-32.png" width="32" height="32">
      Google+
    </a>
  </h1>
</section>
</aside>    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2013 - Rich Wareham -
  <span class="credit">Powered by <a href="http://getpelican.com">Pelican</a></span>
</p></footer>
  	<script type="text/javascript">
	  var disqus_shortname = 'rjw57-blog';
	  (function() {
	    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
	    dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
	    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	   })();
	</script>
  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>
  <script type="text/javascript">
    (function() {
      var script = document.createElement('script'); script.type = 'text/javascript'; script.async = true;
      script.src = 'https://apis.google.com/js/plusone.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(script, s);
    })();
  </script>
</body>
</html>